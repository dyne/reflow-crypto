% /*
%  * This file is part of Reflow
%  * 
%  * Copyright (C) 2021 Dyne.org foundation
%  * designed, written and maintained by Denis Roio <jaromil@dyne.org>
%  * 
%  * This program is free software: you can redistribute it and/or modify
%  * it under the terms of the GNU Affero General Public License v3.0
%  * 
%  * This program is distributed in the hope that it will be useful,
%  * but WITHOUT ANY WARRANTY; without even the implied warranty of
%  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%  * GNU Affero General Public License for more details.
%  * 
%  * Along with this program you should have received a copy of the
%  * GNU Affero General Public License v3.0
%  * If not, see http://www.gnu.org/licenses/agpl.txt
%  * 
%  * Last modified by Denis Roio
%  * on Sunday, 14th March 2021 10:34:16 am
%  */

\documentclass[twocolumn]{article}
\pdfoutput=1

% Roman numbers for sections
\renewcommand{\thesection}{\Roman{section}} 
\renewcommand{\thesubsection}{\thesection.\Roman{subsection}}

\usepackage{arxiv}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{enumitem}
\setlist[itemize]{align=parleft,left=0pt..1em}
\setlist[enumerate]{align=parleft,left=0pt..1.5em,label=\large\protect\textcircled{\small\arabic*}}
\usepackage[font=scriptsize]{caption}
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{lipsum}		% Can be removed after putting your text content
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{doi}
\usepackage{inconsolata}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{booktabs} % For prettier tables

\usepackage{hyperref} % For hyperlinks

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\usepackage{draftwatermark}
\SetWatermarkText{Draft}

\lstdefinestyle{lua}{
  language=[5.3]Lua,
  basicstyle=\ttfamily,
  keywordstyle=\color{magenta},
  stringstyle=\color{blue},
  commentstyle=\color{black!50}
}
% solarized
\lstset{
    % How/what to match
    sensitive=false,
    % Extra margin on line (align with paragraph)
    xleftmargin=\parindent,
    % Put extra space under caption
    belowcaptionskip=1\baselineskip,
    % Break long lines into multiple lines?
    breaklines=true,
    % Show a character for spaces?
    showstringspaces=false,
    tabsize=2
}
\lstdefinelanguage{Zencode}{
	morekeywords = {
		Given,
		When,
		Then,
		And,
		Scenario,
		Rule
	},
	sensitive=true,
	morecomment=[l]{\#},
	morestring=[b]'
}
\lstdefinestyle{zencode}{
  language=Zencode,
  backgroundcolor=\color{white},
  basicstyle=\ttfamily,
  keywordstyle=\color{blue},
  stringstyle=\color{magenta},
  commentstyle=\color{black!50}
}


\title{Reflow}

%\date{September 9, 1985}	% Here you can change the date presented in the paper title
%\date{} 					% Or removing it

\author{
    Denis Roio \\
	Dyne.org foundation \\
	Amsterdam, 1013AK \\
	\texttt{J@Dyne.org} \\
    \And
	Alberto Ibrisevic \\
	Laboratory of Cryptography\\
	Trento University (stage)\\
	\texttt{Bettowski@dyne.org} \\
    \And
    Andrea D'Intino \\
    Dyne.org foundation \\
    Amsterdam, 1013AK \\
    \texttt{Andrea@Dyne.org} \\
}

% Uncomment to remove the date
%\date{}

% Uncomment to override  the `A preprint' in the header
\renewcommand{\headeright}{Dyne.org}
\renewcommand{\undertitle}{Zero Knowledge Multi Party Signatures with Application to Distributed Authentication}
\renewcommand{\shorttitle}{\textit{Reflow}}

\hypersetup{
  pdftitle={Reflow multi-party signatures - Secure BLS multi-signatures Zero-knowledge proof },
  pdfsubject={cs.CR},
  pdfauthor={Denis Roio, Alberto Ibrisevic, Andrea D'Intino},
  pdfkeywords={Cryptography, signatures, zero-knowledge, multi-party, authentication, REA},
}

\begin{document}

\twocolumn[
  \begin{@twocolumnfalse}

\maketitle

\begin{abstract}
Reflow is a novel signature scheme supporting unlinkable
signatures by multiple parties authenticated by means of a
zero-knowledge credential scheme. Reflow integrates with
blockchains to ensure confidentiality, authenticity and availability
even when credential issuing authorities are offline. We implement and
evaluate a Reflow smart contract for Zenroom and present an
application related to multiple anonymous signatures by authenticated
parties and their non-interactive verification. Reflow uses short
and computationally efficient authentication credentials and signatures
application scale linearly over multiple participants.
\end{abstract}

\vspace{2cm}

 \end{@twocolumnfalse}
]

\section{Introduction}

Multi-party computation applied to the signing process allows the
issuance of signatures without requiring any of the participating
parties to disclose secret signing keys to each other, nor requires the
presence of a trusted third-party to receive them and compose the
signatures. However, established schemes have shortcomings. Existing
protocols do not provide the necessary efficiency, re-randomization or
blind issuance properties necessary for the application to trust-less
distributed systems. Those managing to implement such privacy preserving
features are prone to rogue-key attacks \citep{ietf-bls} since they
cannot grant that signatures are produced by legitimate key holders.

The lack of efficient, scalable and privacy-preserving signature schemes
impacts distributed ledger technologies that support 'smart contracts'
as decentralized or federated architectures where trust is not shared
among all participants, but granted by one or more authorities through
credential issuance for the generation of non-interactive and unlinkable
proofs.

Reflow applies to the signature process a mechanism of credential
issuance by one or more authorities for the generation of
non-interactive and unlinkable proofs, resulting in short and
computationally efficient signatures composed of exactly two group
elements that are linked to each other. The size of the signature
remains constant regardless of the number of parties that are signing,
while the credential is verified and discarded after signature
aggregation. While being signed, duplicates may be avoided by collecting
unlinkable fingerprints of signing parties, as they would invalidate the
final result. Before being able to sign, a one-time setup phase is
required where the signing party collects and aggregates a signed
credential from one or more authorities. The attribute showing and
verification are $O(1)$ in terms of both cryptographic computations and
communication of cryptographic material, irrespective of the number of
authorities \citep{coconut-2018}.

Our evaluation of the Multiparty primitives shows very promising
results. Session creation takes about $20ms$, while signing $73ms$ and
verification $40ms$ on average consumer hardware.

\subsection*{Overview}

Reflow provides a production-ready implementation that is easy to embed in end-to-end encryption applications. By making it possible for multiple parties to anonymously authenticate and produce untraceable signatures, its goal is to leverage privacy-by-design scenarios that minimize the information exchange needed for document authentication.

The participation to a signature will be governed by one or more issuers holding keys for the one-time setup of signature credentials. The steps outlined below are represented in figure \ref{fig:credential_diagram}:

\begin{enumerate} % [label=\large\protect\textcircled{\small\arabic*}]
  \item Participant generates keys
  \item Participant sends a credential request to Issuer
  \item Issuer signs the credential request and sends it back
  \item Participant can create anonymous credential proofs
\end{enumerate}

% \begin{itemize}
%   \item[\circled{1}] Participant generates keys and a credential request
%   \item[\circled{2}] Issuer signs the credential request
%   \item[\circled{3}] Participant stores the credential in its keyring
% \end{itemize}


\begin{figure}
  \caption{Basic credential authentication }
  \label{fig:credential_diagram}
  \centering
  \includegraphics[width=0.5\textwidth]{credential_diagram.eps}
\end{figure}


Following this setup any participant will be able to produce a
zero-knowledge proof of possession of the credential, which can be
verified by anyone anonymously on the blockchain.

The base application of Multidarkdroom is obviously the collective
signature of digital documents and the signed credential proof will be a
requirement to participate to any signature process.

A Reflow signature process is best described in 3 main steps:
session creation, signature and verification.

\paragraph*{1. Anyone creates a session}

A session may be created by anyone, no credentials are required, but only information that should be public: the public keys of participants holding a credential to sign, the public verifier of the issuer who has signed the credentials and at last a document to be signed. The steps below are represented in figure \ref{fig:create_session} and illustrate how a signature session is created: 

\begin{enumerate}
  \item Participants will publish their public keys, available to anyone 
  \item Anyone may indict a signature session by selecting a document, the public keys of signing participants and the issuer
  \item The signature session is then published without disclosing the identity of any participant
\end{enumerate}

\begin{figure}
  \caption{Session Creation}
  \label{fig:create_session}
  \centering
  \includegraphics[width=0.5\textwidth]{create_session.eps}
\end{figure}

A Reflow signature session can then be published for verification and its existance may be confidentially communicated to the participants elected to sign it. The possession of the session will allow to disclose the identity of the participants, but only that of the Issuer and the document (or the hash of it) signed.

\paragraph*{2. Participants sign the session}

Only elected participants that were initially chosen to sign the
session may sign it, this is forced through credential
authentication. Whenever they know about the existance of a session
requesting their signature, they may chose to sign it. The steps below
are illustrated in figure \ref{fig:verify_sign}.

\begin{enumerate}
  \item Participants may be informed about the signature session and
    may create an anonymous signature to be added to the session 
  \item Anyone may check that the anonymous signature is authentic
    and not a duplicate, then adds it to the session
  \item Anyone may be informed about the signature session and be able to verify if the document is signed by all and only all participants
\end{enumerate}

\begin{figure}
  \caption{Sign and Verify}
  \label{fig:verify_sign}
  \centering
  \includegraphics[width=0.5\textwidth]{verify_sign.eps}
\end{figure}

A delicate aspect of BLS signatures is avoiding double-signing: if a
participant signs twice then the whole signature will never be valid.
Relying on a stateless credential authentication alone does not avoid
this case in Reflow, therefore we use a list of anonymous
"fingerprints" of the signature related to the document being signed.
Each signature will produce a participant fingerprint saved in a list
that is checked against duplication before adding a new
signature. This procedure adds significant computational overhead for
sessions with a large number of participants, but it can be switched
off in a system that avoids double-signing in its own architecture.

\paragraph*{Anyone verifies signatures}

Until the session will have collected all the signatures of
participants, its verification will not be valid. It is also
impossible to know if all participants have signed the session or how
many are missing. Anyone can verify the state of the signature session
in any moment just by having the document and the session, as
illustrated in figure \ref{fig:verify_sign} along with the signature
process.

Configurable features may be introduced in the Reflow signature
flow that may or may not disclose more information, for instance who
has indicted the signature session, what documents are linked to
signatures and how many participants were called to sign: this depends
from the implementation and the metadata it may add to signature
sessions or the communication protocols adopted.  In any case the
basic signature and verification flow of Reflow requires that
only one identity is really made public and is that of the issuer.

\subsection*{Applications}

Moving further in envisioning the possibilities opened by Reflow
is important to state the possibility to aggregate (sum) signatures into
compact multi-signatures, a core feature of our BLS based signature
scheme \citep{compact-multisig}.

\paragraph*{Need to Know.}

The base implementation exploiting this feature is that of a signature
scheme for a single document split in separate sections to be signed by
different participants: all the signatures can be later aggregated in a
single one proving the whole document has been signed by all
participants, without being disclosed to all of them in its entirety.
This application helps to enforce the principles of need-to-know and
least privilege to the access of information \citep{info-protection} and
is useful for the realization of privacy-aware applications in various
sectors, for instance for medical and risk mitigation analysis.


\paragraph*{Disposable Identities}

A Disposable Identity is based on four properties common to other
authentication and identification systems: verifiability, privacy,
transparency, trustworthiness; then in addition introduces a fifth
property: disposability. Disposability permits purpose-specific and
context-driven authentication, to avoid linking the same identity across
different authentication contexts \citep{dispid}.

Reflow can be adopted by such an application to remove the need of
context-free identifiers and implement authentication functions through
a disposable identity whose traceability is bound to a context UID.
Furthermore, being a signature scheme, Reflow can add the feature of
context-free verifiable signatures (and multi-signatures) that are
untraceable in public, but can be traced and even revoked in a known
context by the means of context-specific signature fingerprints.

This scenario is relevant for the implementation of privacy-preserving
public sector applications that allow authentication and signatures
through disposable identity systems.   


\paragraph*{Material Passport.}
Drawing on feature of multiple signature aggregation, Reflow can
be used to implement a {material passport} for circular economy
applications \citep{material-passport} to maintain the genealogy of a
specific product, providing authenticated information about  the whole
set of actors, tools, collaborations, agreements, efforts and energy
involved in its production, transportation and disposal
\citep{Reflow-os}.

The provision of the information that forms the content of the material
passport should be done by every actor in the supply chain and among the
most important technical necessities for such an application are the
confidentiality issues regarding access to information and the
guarantees of the quality of information \citep{resources-passport}.

As an ideally simple and effective ontology we adopt ValueFlows to organize
knowledge in a graph made of 4 main type of nodes:

\begin{enumerate}
  \item Events that are the mean of creation and transormation of Resources
  \item Agents capable of creating Events and Processes
  \item Processes where more than one Agent can consume and create Events
\end{enumerate}

We then consider Resources as material passports made of the track and
trace of all nodes - Events, Agents and Processes - they descend from.
The  material passport is an authenticated graph structure: in figure
\ref{fig:valueflows} the Resources on the right side have an UID which
is the aggregation of all UIDs of elements leading to their existance.

\begin{figure}
  \caption{Valueflows}
  \label{fig:valueflows}
  \centering
  \includegraphics[width=0.5\textwidth]{valueflows.eps}
\end{figure}

The integrity of the material passport can be verified by recalculating
the UID aggregation and see it matches the signed one attached to the
Resource. In case one or more UIDs are wrong or missing, the Resource
will not verify as valid. In brief is possible that:

\begin{enumerate}
  \item One or more Agents may interact to create material passports
  \item A material passport is the aggregation of all parent nodes
  \item Anyone may verify the integrity and validity of a material passport
  \item The verification of a material passport does not reveal the identity of Agents signing it
  \item One may export and import a material passport as a graph query
\end{enumerate}

Reflow's unlinkability of credentials and signatures satisfy the privacy
requirement for the material passport, while the possibility to
aggregate and link all the elements of its graph allow to group multiple
signatures into a single compact one, without requiring any interaction
with the previous signers. The material passport signature will then be
the sum of all Agents, Processes and Events involved, created or
consumed for it. The Reflow material passport is the authenticated,
immutable and portable track record of all nodes connected in its graph:
material passports can be signed on export and verified on import, which
makes them reliably portable from one graph to another in a federated
environment.

\subsection*{This paper makes three key contributions}

\begin{itemize}
\item We describe the signature scheme underlying Reflow, including how
  key generation, signing and verification operate (Section
  \ref{sec:signature}). The scheme is an application of the BLS signature scheme
  \citep{asiacrypt-bls} fitted with features to grant the unlinkability of
  signatures and to secure it against rogue-key attacks.
\item We describe the credential scheme underlying Reflow, including how
  key generation, issuance, aggregation and verification of credentials operate
  (Section \ref{sec:credential}). The scheme is an application of the Coconut
  credential scheme \citep{coconut-2018} that is general purpose and can be
  scaled to a fully distributed issuance that is re-randomizable.
\item We implement a Zencode scenario of Reflow to be executed on and
  off-chain by the Zenroom VM, complete with functions for public credential
  issuance, signature session creation and multi-party non-interactive signing
  (Section \ref{sec:implementation}). We evaluate the performance and cost of
  this implementation on on-site and on-line platforms leveraging end-to-end
  encryption (Section \ref{sec:evaluation}).
\end{itemize}

\subsection*{Notations and assumptions}

We will adopt the following notations:
\begin{itemize}
    \item $\mathbb{F}_p$ is the prime finite field with $p$ elements (i.e. of prime order $p$); % In our case the prime is long 383 bits;
    \item $E$ denotes the (additive) group of points of the curve BLS-383 \citep{bls383} which can be described with the Weierstrass form  $y^2=x^3 + 16$; 
    \item $E_T$ represents instead the group of points of the twisted curve of BLS-383, with embedding degree $k=12$. The order of this group is the same of that of $E$;
\end{itemize}
We also require defining the notion of a cryptographic pairing. Basically it is a function $e: \mathbb{G}_1\times\mathbb{G}_2\to \mathbb{G}_T$, where $\mathbb{G}_1,\mathbb{G}_2$ and $\mathbb{G}_T$ are all groups of same order $n$, such that satisfies the following properties:
\begin{itemize}
    \item [i.] \emph{Bilinearity}, i.e. given $P_1,Q_1\in\mathbb{G}_1$ and $P_2,Q_2\in\mathbb{G}_2$, we have 
%    \item [i.] \emph{Bilinearity}, i.e. given $P,Q\in\mathbb{G}_1$ and $R,S\in\mathbb{G}_2$, we have 
    \begin{align*}
        e(P_1+Q_1,P_2) = e(P_1,P_2)\cdot e(Q_1,P_2) \\
        e(P_1,P_2+Q_2) = e(P_1,P_2)\cdot e(P_1,Q_2)
    \end{align*}
    \item[ii.] \emph{Non-degeneracy}, meaning that for all $g_1\in\mathbb{G}_1, g_2\in\mathbb{G}_2$, $e(g_1,g_2)\ne 1_{\mathbb{G}_T}$, the identity element of the group $\mathbb{G}_T$;
    \item[iii.] \emph{ Efficiency}, so that the map $e$ is easy to compute;
    \item[iv. ] $\mathbb{G}_1\ne \mathbb{G}_2$, and moreover, that there exist no efficient homomorphism between $\mathbb{G}_1$ and $\mathbb{G}_2$.
\end{itemize}
For the purpose of our protocol we will have $\mathbb{G}_1 = E_T$ and $\mathbb{G}_2 = E$, and $\mathbb{G}_T\subset \mathbb{F}_{p^{12}}$ is the subgroup containing the $n$-th roots of unity, where $n$ is the order of the groups $E$ and $E_T$. Instead $e: E_T  \times E\to \mathbb{G}_T$ is the \emph{Miller pairing}, which in our work is encoded as the method \verb!miller(ECP2 P, ECP Q)!. \\
To conclude, the credential scheme in section \ref{sec:credential} uses non-interactive zero-knowledge proofs (for short NIZK proofs) to assert knowledge and relations over discrete logarithm values. They will be represented using the notation introduced by \cite{camenisch} as 
\[
\text{NIZK}\{(x,y,\dots): text{statements about x, y,}\dots \}
\]

% I. Signature scheme (BLS)
\section{Signature}
\label{sec:signature}

A \emph{BLS signature} is a signature scheme whose design exploits a cryptographic pairing. As for other well known algorithm such as ECDSA, it will work following these three main steps:
\begin{itemize}
    \item  \textbf{Key Generation phase.} For a user who wants to sign a message $m$, a secret key $sk$ is randomically chosen uniformly in $\mathbb{F}_n$, where $n$ is the order of the groups $\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T$. The corresponding public key $pk$ is the element $sk\cdot G_2\in E_T$;
    \item   \textbf{Signing phase.} The message $m$ is first hashed
      into the point $U\in E$, which in our scheme is done by the
      method \verb!hashtopoint!; the related signature is then given
      by $\sigma = sk\cdot U$;
    \item   \textbf{Verification phase.} For an other user that wants to verify the authenticity and the integrity of the message $m$, it needs to
    \begin{itemize}
        \item [1.] parse $m, pk$ and $\sigma$
        \item [2.] hash the message $m$ into the point $U$ and then check if the following identity holds,
        \[
        e(pk,U) = e(G_2,\sigma)
        \]
    \end{itemize}
\end{itemize}
If verification passes it means that $\sigma$ is a valid signature for $m$ and the protocol ends without errors.
\begin{proof}
 [Proof of the verification algorithm:] By using the definitions of the elements involved and exploiting the property of the pairing $e$ we have
\[
\begin{split}
    e(pk,U) &= e(sk\cdot G_2, U) \\
            &= e(G_2,U)^{sk}\\
            &= e(G_2,sk\cdot U)\\
            &= e(G_2,\sigma)
\end{split}
\]
\end{proof}

BLS signatures present some interesting features. For instance, the length of the output $\sigma$ competes to those obtained by ECDSA and similar algorithms; in our specific case, by using BLS-383 \citep{bls383}, it will be 32 Bytes long, which is typically a standard nowadays. Then, since this curve is also pairing-friendly, meaning that (with the assumption made on $e$) signature and verification are obtained in very short time. Moreover, BLS supports also aggregation, that is the ability to aggregate a collection of multiple signatures $\sigma_i$ (each one related to a different message $m_i$) into a singular new object $\sigma$, that can be validated using the respective public keys $pk_i$ in a suitable way. This is possible thanks to the fact that $\sigma_i\in G_1 \forall i$, giving to the algorithm an homomorphic property. We will show now how this last feature can be attained in the context of a multi-party computation using the same message $m$ but different participants.

\subsection*{Session Generation}

After the key generation step we introduce a new phase called \textbf{session generation}, where the signature is initialized; anyone willing to start a signing session on a message $m$ will create:
\begin{itemize}
    \item[1.] a random $r$ and its corresponding point $R = r\cdot G_2$
    \item[2.] the sum of $R$ and all $pk$ supposed to participate to the signature such as $P = R + \sum_i pk_i$
    \item[3.] the unique identifier \verb!UID! of the session calculated as hash to point of the message $m$, such as $U = H(m)\in E$, where $H$ is a combination of a cryptographic hash function (treated as a random oracle) together with an encoding into elliptic curve points procedure
    \item[4.] the first layer of the signature $\sigma \leftarrow r\cdot U$, later to be summed with all other signatures in a multi-party computation setup resulting in the final signature as $\sigma \leftarrow r\cdot U + \sum_i sk_i\cdot U$
    \item[5.] the array of unique fingerprints $\zeta_i$ of each signature resulting from the credential authentication (see section \ref{sec:credential}) 
\end{itemize}
After this phase is terminated, every participants involved in the session start their own signing phase during the session, producing (from the same message $m$) their respective $\sigma_i$'s. The final signature $\sigma$ is then computed in this way: first of all let us call $\sigma_0 = r\cdot U$, then supposing $k$ participants have already aggrgated their $\sigma_i$, obtaining a partial signature $S_k$, the $(k+1)$-th one will compute
\[
  S_{k+1}=S_k+\sigma_k = \sum_{i=0}^{k+1} \sigma_i
\]
Finally, the resulting output will be $\sigma = S_N$, where $N$ is the total number of the signers of the session. In order to verify that $\sigma$ is valid we compute $P = R + \sum_{i=0} ^N pk_i$, where $R = r\cdot G_2$, working as a public key with respect to the nonce $r$, which instead is kept secret. Verification is then performed by checking if the following identity holds
    \[ 
    e(P,U) = e(G_2,\sigma)
    \]
If verification passes without errors it means that $\sigma$ is a valid aggregated signature of $m$.
\begin{proof}
%For simplicity we will prove the above statement for $N=2$, since the general case can be obtained by an inductive argument. 
By recalling that $\sigma = r\cdot U + \sum_{i=1}^N \sigma_i$, $P = R + \sum_{i=1}^N pk_i$, by using the property of the pairing $e$ we have
\[
\begin{split}
    e(P,U)  &= e(R + \sum_{i=1}^N pk_i, U) \\
            &= e((r + \sum_{i=1}^N sk_i)\cdot G_2,U)\\
            &= e(G_2,U)^{r + \sum_{i=1}^N sk_i}\\
            &= e(G_2,(r + \sum_{i=1}^N sk_i)\cdot U) \\
            &= e(G_2,r\cdot U + \sum_{i=1}^N \sigma_i) \\
            &= e(G_2,\sigma)
\end{split}
\]
\end{proof} 
We conclude this section with a final consideration on this feature. We recall that in the generation of the aggregated signature $\sigma$ we used as a starting point the variable $\sigma_0 = r\cdot U$, but in literature it is also common to find instead simply the base point $G_2$. The choice of randomizing it (providing that the random number generator acts as an oracle) helps in preventing replay attacks, since the signature generated by the process is linked to the session in which is produced, for if an attacker managed to get some information from $\sigma$, it would be difficult to use it in order to forge new signatures.

\section{Credential}
\label{sec:credential}

Following the guidelines of Coconut, the credentials issuing scheme works as follows:
\begin{itemize}
\item [1.] the issuer generates its own keypair $(s_k,v_k)$, where $s_k=(x,y)\in\mathbb{Z}^2$ is the pair of secret scalars (the signing key) and $v_k=(\alpha, \beta)=(x\cdot G_2,y\cdot G_2)$ is the verifying key, made by the related pair of public points over $E_T$; 
\item [2.] the user $i$, with its respective keys $(sk_i, PK_i)$ make a credential request on its secret attribute $ck_i\in\mathbb{Z}$ to the issuer, represented by $\lambda$ which contains a zero-knowledge proof $\pi_s$ of the authenticity of user $i$; 
\item[3.] the issuer, after having received $\lambda$, verifies the proof $\pi_s$ at its inside, and if it passes, then releases to user $i$ a credential $\tilde{\sigma}$ signed used its own key $sk$.
\end{itemize}
Step 1. is self-explanatory. Steps 2. and 3. require a bit more effort, in fact in order to build a valid request $\lambda$, and so also a valid proof $\pi_s$, first of all the user must produce an hash digest for the attribute $ck_i$, that we call $h$, then computes two more variables $c$ and $s_h$ defined as
\begin{align*}
c &= r\cdot G_1 + h\cdot HS \\
s_h &= (a,b) = (k \cdot G_1, k\cdot \gamma + h\cdot c)
\end{align*}
where $r$ and $k$ are fresh randomly generated integers, $HS$ is an hard-encoded point on the curve $E$, and $\gamma = ck_i\cdot G_1$. These two variables are alleged in the credential request $\lambda$ produced in \verb!prepare_blind_sign! and are needed to the verifier to assure the authenticity of the user through the proof $\pi_s$, which requires as input $h, k, r, c$. The Non-Iteractive Zero Knowledge proof (for short NIZK proof) $\pi_s$ generated by the function \verb!blind_sign! is computed as follows:
\begin{itemize}
    \item \textbf{Randomization phase.} Three new nonces $w_h, w_k, w_r\in \mathbb{Z}$ are generated, each one related to the input variables $h, k, r$ respectively as we will show soon; 
    \item \textbf{Challenge phase.} The protocol creates three commitment values, namely $A_w, B_w, C_w$ defined as follows
    \begin{align*}
        A_w &= w_k\cdot G_1 \\ 
        B_w &= w_k\cdot\gamma + w_h\cdot c \\
        C_w &= w_r\cdot G_1 + w_h \cdot HS
    \end{align*}
    Then these variables are used as input of a function $\varphi$ producing an integer $c_h=\varphi(\{c,A_w,B_w,C_w\})$;
    \item \textbf{Response phase.} In order that the proof can be verified the protocol generates three more variables which are alleged inside the proof itself and link the nonces $w_h, w_k, w_r$ with $h, k, r$, i.e:
    \begin{align*}
        r_h &= w_h - c_h h \\
        r_k &= w_k - c_h k \\
        r_r &= w_r - c_h r
    \end{align*}
\end{itemize}
So basically the proof $\pi_s$ contains the three response variables $r_h, r_k, r_r$ and also the commitment value $c_h$, that can be used for a predicate $\phi$ which is true when computed on $h$. Once the verifier receives the request $\lambda$, in order to check if the proof is valid it should be able to reconstruct  $A_w, B_w, C_w$ by doing these computations,
\begin{align*}
\widehat{A}_w &= c_h\cdot a + r_k\cdot G_1 \\
\widehat{B}_w &= c_h\cdot b + r_k\cdot \gamma + r_h\cdot c \\
\widehat{C}_w &= c_h\cdot c + r_r\cdot G_1 + r_h\cdot HS
\end{align*}
If the request is correct, then we will have that 
\begin{equation}\label{challenge pi_s}
\varphi(\{c,\widehat{A}_w,\widehat{B}_w,\widehat{C}_w\}) = \varphi(\{c,A_w,B_w,C_w\}) = c_h
\end{equation}
and verification is thus complete, meaning that the verifier has right to believe that the prover actually owns the secret attribute $ck_i$ associated to the public variable $\gamma$ and that consequently has produced a valid commitment $c$ and (El-Gamal) encryption $s$; in other words,
\begin{align*}
\pi_s = \text{ NIZK}\{&(ck_i, h, r, k): \\
&\gamma = ck_i\cdot G_1, \\
&c = r\cdot G_1 + h\cdot HS, \\
&s_h = (k \cdot G_1, k\cdot \gamma + h\cdot c), \\
&\phi(h)=1\}
\end{align*}
At this point the user will now have a blind credential $\tilde{\sigma} = (c, \tilde{a}, \tilde{b})$ issued by the authority, where
\begin{align*} \\
\tilde{a} &= y \cdot a \\
\tilde{b} &= x\cdot c + y\cdot b
\end{align*}
The user then will have to un-blind it using its secret credential key, obtaining $\sigma_{ck} = (c, s) = (c, \tilde{b} - ck_i (\tilde{a}))$, which will use to prove its identity when signing a message. The procedure is similar to the one seen before with some extra details:
\begin{itemize}
    \item \textbf{Setup.} As for the the BLS signature, an elliptic point $U$, associated to the hash of the message to sign, is required as an Unique Identifier (\verb!UID!) for the signing session;
    \item \textbf{Credential proving.} The user produces two cryptographical objects $\theta$ (containing a new proof $\pi_v$) and $\zeta$ (which is unequivocally associated to $U$) through \verb!prove_cred_uid!, taking as input its own credential $\sigma$, the related secret attribute $c_k$, the authority public key $v_k = (\alpha, \beta)$ and the session point $U$.
\end{itemize}
The new objects $\theta$ and $\zeta$ are derived as follows:
\begin{itemize}
    \item as before the user hashes $ck$ into $h$, and this time generates two random values $r$ and $r'$;\\
    \item next, it randomizes its credential $\sigma_{ck}$ into $\sigma_{ck}' = (c', s') = (r'\cdot c, r'\cdot s)$ and then computes two elliptic curve points $\kappa$ and $\nu$ as
    \begin{align*}
        \kappa &= \alpha + h\cdot\beta + r\cdot G_2\\
        \nu &= r \cdot c'
    \end{align*}\\
    \item finally, $\theta$ will be the t-uple $(\kappa, \nu, \pi_v, \phi')$, where $\pi_v$ is a valid zero knowledge proof of the following form
    \begin{align*}
        \pi_v = \text{ NIZK}\{&(h, r): \\
        &\kappa = \alpha + h\cdot\beta + r\cdot G_2\\
        &\nu = r \cdot c' \\
        &\phi'(h)=1\}
    \end{align*}
    with $\phi'$ being a predicate which is true on $h$; 
    \item $\zeta$ will be instead the elliptic curve point obtained as $h\cdot U \in E$.
\end{itemize}
Building the proof $\pi_v$ requires similar steps as seen for $\pi_s$, in fact we create three commitment values $A_w, B_w, C_w$ defined as
\begin{align*}
    A_w &= \alpha + w_h\cdot \beta + w_r \cdot G_2 \\
    B_w &= w_r\cdot c' \\
    C_w &= w_h\cdot U
\end{align*}
where $w_h, w_r$ are fresh generated nonces; then we set the challenge as the computation of $c_h=\varphi(\{\alpha,\beta,A_w,B_w,C_w\})$ with the related responses 
\begin{align*}
    r_h &= w_h - hc \\
    r_r &= w_r - rc
\end{align*}
The values of $r_h$ and $r_r$ are stored inside $\pi_v$ which will be then sent through $\theta$ (together with $\zeta$) from the prover to the verifier. In order to check that the user has legitimately generated the proof and at the same time is the owner of the credential the following steps must be made:
\begin{itemize}
    \item[1.] extracting $\kappa, \nu, \pi_v$ (which is $(r_h,r_r, c_h))$ from $\theta$;
    \item[2.] reconstructing the commitments $A_w, B_w, C_w$ as
    \begin{align*}
        \widehat{A}_w &= c_h\cdot \kappa + r_r\cdot G_2 + (1 - c_h) \cdot\alpha + r_h \cdot \beta \\
        \widehat{B}_w &= r_r\cdot c' + c_h\cdot \nu \\
        \widehat{C}_w &= r_h\cdot U + c_h\cdot \zeta
    \end{align*}
    \item[3.] checking either that
    \begin{multline}\label{challenge pi_v}  \varphi(\{\alpha,\beta,\widehat{A}_w,\widehat{B}_w,\widehat{C}_w\}) = \\ \varphi(\{\alpha,\beta,A_w,B_w,C_w\}) = c_h,
    \end{multline}
    that $c' \ne O$, the point at infinity, and that
    \begin{equation}\label{miller}
    e(\kappa, c') = e(G_2, s' + \nu)
    \end{equation}
    \end{itemize}
Actually the predicate $\phi$ in the definition of $\pi_v$ can be thought as performing steps 2. and 3. and, if any of these fails the protocol will abort returning a failure, otherwise verification passes and the user can finally produce the signature.

\subsection*{Proof of the verification algorithms.}

We now show for the proof $\pi_s$ that actually by using the responses $r_h, r_k$ and $r_r$, together with $c_h$ and the other parameters inside $\lambda$, i.e. $s=(a,b), c$ and $\gamma$, using also the hard coded point $HS$, it is possible to reconstruct the commitments $A_w, B_w, C_w$:
\begin{align*}
    \widehat{A}_w   &= c_h\cdot a + r_k\cdot G_1 = c_h k \cdot G_1 + r_k \cdot G_1 \\
                    &= (c_h k + r_k)\cdot G_1 = (c_h k + w_k - c_h k)\cdot G_1 \\
                    &= w_k\cdot G_1 = A_w \\
    \widehat{B}_w   &= c_h\cdot b + r_k\cdot \gamma + r_h\cdot c \\
                    &= c_h\cdot (k\cdot \gamma + h\cdot c) + r_k\cdot\gamma + r_h\cdot c \\
                    &= (c_h k + r_k) \cdot\gamma + (c_h h + r_h\cdot c) \\
                    &= (c_h k + w_k - c_h k ) \cdot\gamma + (c_h h + w_h - c_h h)\cdot c \\
                    &= w_k\cdot\gamma + w_h\cdot c = B_w \\
    \widehat{C}_w   &= c_h\cdot c + r_r\cdot G_1 + r_h\cdot HS \\
                    &= c_h\cdot (r\cdot G_1 + h\cdot HS) + r_r\cdot G_1 + r_h\cdot HS \\
                    &= (c_h r + r_r)\cdot G_1 + (c_h h + r_h)\cdot HS \\
                    &= (c_h r + w_r - c_h r)\cdot G_1 + (c_h h + w_h - c_h h)\cdot HS \\
                    &= w_r \cdot G_1 + w_h\cdot HS = C_w
\end{align*} 
Regarding the second proof $\pi_v$, we have to prove both the identities (\ref{challenge pi_v}) and (\ref{miller}) hold. We will focus only on the latter since the former requires a similar approach on what we have have done for $\pi_s$, but with different parameters involved ($\kappa, \nu$, etc.). The left-hand side of the relation can be expressed as
\begin{align*}
    e(\kappa, c') &= e(\alpha + h\cdot\beta + r\cdot G_2, c') \\
    &= e(x\cdot G_2 + hy\cdot G_2  + r\cdot G_2,\tilde{r}\cdot G_1) \\
    &= e((x+hy+r)\cdot G_2, \tilde{r}\cdot G_1) \\
    &= e(G_2,G_1)^{(x+hy+r)\tilde{r}}
\end{align*}
using the substitution $c'=\tilde{r}\cdot G_1$, with $\tilde{r}\in\mathbb{F}_p$ since we know that $c'\in E$. For the right-hand side we have instead
\begin{align*}
    e(G_2, s' + \nu) &= e(G_2, r'\cdot s + r \cdot c') \\
    &= e(G_2, r'(\tilde{b} - ck_i y (\tilde{a})) + r \cdot c') \\
    &= e(G_2, r'(x\cdot c + y\cdot b - ck_i y\cdot a) + r \cdot c') \\
    &= e(G_2, r'(x\cdot c + y\cdot b - ck_i y\cdot a + r \cdot c)) 
\end{align*}
The second argument of the pairing can be rewritten as
\[
\begin{split}
    &r'(x\cdot c + y\cdot b - ck_i y\cdot a + r \cdot c) = \\
    &r'(x\cdot c + y(k\cdot \gamma + h\cdot c) - (ck_i) yk\cdot G_1 + r \cdot c) = \\
    &r'(x\cdot c + yh\cdot c + yk(ck_i)\cdot G_1  - yk(ck_i)\cdot G_1 + r \cdot c) = \\
    &r'(x + yh + r) \cdot c
\end{split}
\]
So, at the end
\[
\begin{split}
    e(G_2, s' + \nu) &= e(G_2, r'(x\cdot c + y\cdot b - dy\cdot a + r \cdot c)) \\
    &= e(G_2, r'(x + yh + r) \cdot c) \\
    &= e(G_2,(x+hy+r)\tilde{r}\cdot G_1) \\
    &= e(G_2,G_1)^{(x+hy+r)\tilde{r}}
\end{split}
\]
and (\ref{miller}) is finally proved. 
\qed

\subsection*{Security considerations.} 

As mentioned in Coconut \citep{coconut-2018}, BLS signatures and the
proof system obtained with credentials are considered secure by assuming
the existence of random oracles \citep{random-oracle}, together with the
decisional Diffie-Hellman Problem (DDH) \citep{DDH-problem}, the
external Diffie-Hellman Problem (XDH), and with the
Lysyanskaya-Rivest-Sahai-Wol Problem (LRSW) \citep{lrsw-assumption},
which are connected to the Discrete Logarithm. In fact, under these
assumptions, we have that our protocol satisfies unforgeability,
blindness, and unlinkability.

Reserves can be made about the maturity of pairing-based ellipcic
curve cryptography despite various efforts to measure its security and
design curve parameters that raise it, it is reasonable to consider
this as a pioneering field of cryptography in contrast to well tested
standards.

In addition to considerations on the maturity of EC, the future growth
of quantum-computing technologies may be able to overcome the Discrete
Logarithmic assumptions by qualitatively different computational
means. Reflow then may be vulnerable to quantum-computing
attacks, as well hard to patch, because the pairing-based design sits
at its core with the adoption of ATE / Miller loop pairing of curves
in twisted space, a practice that is not covered by research on
quantum-proof algorithms and will eventually need more time to be
addressed; however this is all speculative reasoning on what we can
expect from the future.

The Reflow implementation we are presenting in this paper and
that we have published as a Zenroom scenario ready to use is based on
the BLS383 curve \citep{bls383} that in the current implementation
provided by the AMCL library has shown to pass all lab-tests regarding
pairing properties, a positive result that is not shared with the
slightly different BLS381-12 curve adopted by ETH2.0. Debating the
choice of BLS381 is well beyond the scope of this paper, but is worth
mentioning that our lab-tests have proved also the BLS461 curve to work
in Reflow: it is based on a 461 bit prime and hence upgrades our
implementation to 128 bit security \citep{updating-key-pairings} against
attacks looking for discrete logs on elliptic curves
\citep{discrete-log-attack}.

At last the complexity and flexibility of Reflow in its
different applications, its optional use of fingerprint lists,
multiple UIDs saved from aggregation and other features covering the
different applications also represent a security risk in the technical
integration phase. We believe that the adoption of Zenroom and the
creation of a Zencode scenario addresses well this vulnerability by
providing an easy to use integrated development environment
(apiroom.net) and a test-bed for the design of different scenarios of
application for Reflow that can be deployed correctly granting
end-to-end encryption and data minimization according to privacy by
design guidelines \citep{privbydesign}.

\section{Implementation}
\label{sec:implementation}

% \lstset{basicstyle=\ttfamily\scriptsize, breaklines=true}

In this section we illustrate our implementation of Reflow
keygen, sign and verify operations outlining for each:

\begin{itemize}
  \item the communication sequence diagram
 % \item the Zenroom code (Lua dialect script)
  \item the Zencode statements composing the sequence 
\end{itemize}

Zencode is actual code executed inside the Zenroom VM, behind its
implementation the algorithms follow closely the mathematical
formulation explained in this article and can be reviewed in the free
and open source code published at Zenroom.org: the Reflow Zencode
scenario implementation is contained inside the Zenroom source
code.

\subsection*{Credential Setup}

We begin with the Credential Setup sequence which has to be executed
only once to enable participants to produce signatures. This sequence is
briefly illustrated with a diagram and it consists in the creation of
keypair for both the Issuer, who will sign the participant credentials,
and the participant who will request an issuer credential.

\begin{lstlisting}[style=zencode,caption={Issuer Keygen}]
Given I am 'The Issuer'
When I create the issuer key
Then print my 'keys'  
\end{lstlisting}

Executed by the Zencode utterance:

\textbf{When I create the issuer keypair}

It will create a new \emph{issuer keypair} that can be used to sign
each new \emph{credential request}. Its public member \emph{.verify}
should be public and know to anyone willing to verify the credentials
of signers.

\textbf{Keygen:} Generate a credential request and have it signed by
an Issuer, as well generate a BLS keypair used to sign documents. This
procedure will generate private keys that should not be communicated,
as well public BLS keys that can be aggregated for signature
verification.

Figure~\ref{fig:keygen} illustrates how this process consists of two
different function calls: \verb!keygen! to create an ElGamal keypair
and \verb!prepare_blind_sign! to generate a Coconut credential
request. An interactive exchange takes place between the Signer and
the Issuer that verifies the possession of the secret ElGamal key and
signs a credential to witness this condition.

\begin{figure}
  \caption{Keygen process sequence diagram}
  \label{fig:keygen}
  \centering
  \includegraphics[width=0.5\textwidth]{keygen-seq.png}
\end{figure}

The public key of the Issuer which is used to sign the credential
should have been public and known by the Signer at the beginning of
the keygen process, while at the end of this process the public
ElGamal key should be published, i.e. on a distributed ledger.

The following Zenroom implementation makes use of the Coconut
built-in extension for zero-knowledge proof credentials.

\begin{lstlisting}[basicstyle=\tiny,style=lua]
ZK = require_once('crypto_abc')
issuer = ZK.issuer_keygen() -- setup
sk = INT.random() -- signing key
ck = INT.random() -- credential key
PK = G2 * sk     -- signature verifier
Lambda =
 ZK.prepare_blind_sign(ck * G1, ck)
SigmaTilde =
 ZK.blind_sign(issuer.sign, Lambda)
Sigma =
 ZK.aggregate_creds(ck, {SigmaTilde})
\end{lstlisting}

This code is executed in multiple steps by the Zencode utterances:

\begin{enumerate}

\item \textbf{When I create the credential keypair}

  will create a new \emph{credential keypair} object containing
  members \emph{public} (ECP) and \emph{private} (BIG).

\item \textbf{When I create the credential request}

  will use the \emph{credential keypair} to create a new
  \emph{credential request} complex schema object for ZK proof.

\item \textbf{When I create the credential signature}

  will be executed by the Issuer after the proof-of-possession
  challenge is positive (exchange and confirmation of an encrypted
  message using BLS public keys) to sign the credential.

\item \textbf{When I create the credentials}

  will aggregate one or more \emph{credential signature} (SigmaTilde)
  together with the \emph{private} member of the \emph{credential
    keypair} and finally create \emph{credentials} capable of
  producing Zero-Knowledge proofs of possession.

\end{enumerate}



\textbf{Sign:}

\begin{figure}
  \caption{Signing process sequence diagram}
  \centering
  \includegraphics[width=0.4\textwidth]{sign-seq}
\end{figure}

\textbf{Verify:}

\begin{figure}
  \caption{Verification process sequence diagram}
  \centering
  \includegraphics[width=0.4\textwidth]{verify-seq}
\end{figure}



\begin{lstlisting}[style=lua]

---------
-- SETUP
---------

G1 = ECP.generator()
G2 = ECP2.generator()

-- credentials
ZK = require_once('crypto_abc')
issuer = ZK.issuer_keygen()

-- keygen
sk1 = INT.random() -- signing key
ck1 = INT.random() -- credential key
PK1 = G2 * sk1     -- signature verifier

sk2 = INT.random()
ck2 = INT.random()
PK2 = G2 * sk2

-- issuer sign ZK credentials
Lambda1 = ZK.prepare_blind_sign(ck1*G1, ck1) -- credential request:       p -> i
SigmaTilde1 = ZK.blind_sign(issuer.sign, Lambda1)    -- issuer signs credential:  i -> p
Sigma1 = ZK.aggregate_creds(ck1, {SigmaTilde1})  -- credential sigma          p -> store

Lambda2 = ZK.prepare_blind_sign(ck2*G1, ck2)
SigmaTilde2 = ZK.blind_sign(issuer.sign, Lambda2)
Sigma2 = ZK.aggregate_creds(ck2, {SigmaTilde2})

-- sign

UID = ECP.hashtopoint(msg) -- the message's hash is the unique identifier

--------------
-- SETUP done
--------------

print "--------------------------"
print "first base signing session"
r = INT.random()
R = UID * r      -- session

-- add public keys to public session key
PM = (G2 * r) + PK1 + PK2

-- Session opener broadcasts:
-- 1. R   - base G1 point for signature session
-- 2. PM  - base G2 point for public multi-signature key
-- 3. msg - the message to be signed

-- proofs of valid signature
-- uses public session key as UID
Proof1,z1 = ZK.prove_cred_uid(issuer.verify, Sigma1, ck1, UID)
Proof2,z2 = ZK.prove_cred_uid(issuer.verify, Sigma2, ck2, UID)
-- each signer signs
S1 = UID * sk1
S2 = UID * sk2

-- generate the signature
-- each signer will communicate: UID * sk
SM = R + S1 + S2


-- print signature contents to screen
I.print({pub = PM, -- session public keys
		 sign = SM,
		 uid = UID,
		 proofhash1 = sha256( ZEN.serialize( Proof1 ) ),
		 proofhash2 = sha256( ZEN.serialize( Proof2 ) ),
		 zeta1 = z1,
		 zeta2 = z2,
		 issuer = issuer.verify
})

-- verify
assert( ZK.verify_cred_uid(issuer.verify, Proof1, z1, UID),
		"first proof verification fails")
assert( ZK.verify_cred_uid(issuer.verify, Proof2, z2, UID),
		"second proof verification fails")
assert( ECP2.miller(PM, UID)
		   == ECP2.miller(G2, SM),
        "Signature doesn't validates")

\end{lstlisting}

\pagebreak

\section{Evaluation}
\label{sec:evaluation}

This section lists results of evaluation benchmarks we have run using the Zencode scenario implementation of Reflow on 4 target platforms:
\begin{itemize}
  \item \textbf{X86 64bit} on a Intel i5 4th generation
  \item \textbf{ARM 64bit} on a Raspberry Pi 4 board
  \item \textbf{ARM 32bit} on a Raspberry Pi 0 board
  \item \textbf{WASM 32bit} on a build made with Emscripten
\end{itemize}

Our benchmarks provide lab measurements for the 3 main steps in the signature flow: for each of them is reported the time of execution (expressed in milliseconds) and the size of output (expressed in bytes) in different conditions with a progressive number $\sigma_N$ of participants (5, 10, 50, 100 signatures).

% All results are produced using the free and open source \emph{AGPLv3 license} Zenroom VM long term support release \emph{version 1.2} and its built-in credentials and Reflow scenarios using the zencode scripts released in the zencode_reflow distributed examples.

% size progression: 5,10,50,100 participants:
% byte size & 444 & 603 & 624  \\
% byte size & 444 & 1171 & 1192  \\
% byte size & 444 & 4011 & 4032  \\
% byte size & 444 & 7561 & 7582  \\


INIZIO ANDREA

\section{Evaluation}
\label{sec:evaluation}



The goal of this section was to produce benchmarks of the implementation of the crypto flow, in  realistic conditions of use, so in a way that is similar to how a software solution would use the software. 

Our approach was opposite to testing single algorithms in a sandbox or a profiler, instead we tested Zenroom scripts, written in Zencode, that include also loading and parsing input data from streams or file system, as well as producing output as a deterministically formed JSON object. 

\subsection*{Platforms}
The three target platforms used for the benchmarks were: 
\begin{itemize}
  \item   \textbf{X86-64} on Intel(R) Core(TM) i5-5300U CPU @ 2.30GHz, running Ubuntu 18.04 (64 bit)
  \item   \textbf{ARM 32bit} on Raspberry Pi 4 board, running Raspberry Pi OS (32bit, kernel version: 5.10)
  \item  \textbf{ARM 32bit} on Raspberry Pi 0 board, running Raspberry Pi OS (32bit, kernel version: 5.10)
\end{itemize}

The the X86-64 machine runs on a Lenovo X250 laptop, with 8GB of RAM.  
The Raspberry 0 and 4 have been chosen as benchmarking platforms because of their similarities to, respectively, very low-cost IoT devices (5 USD) and very low cost mobile phones (sub 100 USD).

\subsection*{Builds} 

Being a self-contained application written in C, Zenroom can be built for several CPU architectures and operative systems, both as command line interface (CLI) application and as a library. The configurations We chose for this benchmark are: 

\begin{itemize}
\item Two binary Zenroom CLI, compiled on the GCC toolchain in native 32bit ELF binaries, once for the X86-64 platform and once for the ARMv7-32bit. We refer to these builds as \textbf{Zenroom CLI}. 

\item One mixed library, transcompiled to WASM using the Emscripten toolchain, then built into an NPM package along with a JavaScript wrapper. At build time, the compiled WASM is converted to base64 and embedded in the JavaScript wrapper, which unpacks it at run-time. 
The library runs in browsers (using the native WASM support, currently present in Chromium/Chrome, Firefox and Safari), as well in node JS based application. We refer to this build as \textbf{Zenroom WASM}. 
\end{itemize}

\subsection*{CLI and WASM use cases} 

The use case the CLI application is typically a server-side application or micro-service. The WASM library can run iin the browser, as the client side of a web application, in a server-side application based on node JS or a mobile application.

Zenroom may also be built as a native library for Android and iOS (on ARM 32bit, ARM 32bit or X86), but no benchmarks of the Reflow crypto flow have been performed using Zenroom as a native library. 
In other benchmarks, not published on this paper, we noted similar performances for the native CLI and the native library versions of Zenrooms: we may therefore assume (!!!! VA BENE???)  

\subsection*{Testing}
Benchmarking of Zenroom CLI and Zenroom WASM required using two different tools. Both tools performed chained execution of the Zenroom scripts and allowed for parametrized execution, where the amount of participants and the number of recursion cycles can be configured.  

\begin{itemize}
\item The testing of Zenroom CLI was executed using a single, self-contained \href{https://github.com/dyne/Zenroom/blob/master/test/zencode_reflow/run-recursive.sh}{bash script}. The script outputs the duration of the execution of each Zenroom scripts, along with the memory usage and size of output data, in a CSV formatted summary. The script also saves to files both the data and scripts for quality control reference.

\item The testing of Zenroom WASM required building a \href{https://github.com/dyne/Reflow-Zencode-WASM-benchmark}{JavaScript application}, running in node JS. The application outputs the duration of the execution of each Zenroom scripts, along with the memory usage, it calculate averages and retursn output in a JSON formatted summary.
\end{itemize}

Benchmarks for the crypto flow were run on both the CLI and the WASM builds of Zenroom, for each platform, for a total of six different data collections. 

\subsection*{Scripts description}

Our benchmarks provide measurements for the all the steps in the signature flow: for each of them is reported the time of execution (expressed in seconds) and the size of output (expressed in bytes) in different conditions with a progressive number of participants (5, 10, 50, 100, 1000 signatures).

The scripts used in the flow and for bench-marking can be divided in three categories: 

\begin{itemize}
\item Scripts with \textbf{variable execution times} executed by anyone and marked with (A), include the creation of the Reflow seal (Session start), the aggregation of the signatures (Collect sign) and the verification of the signatures on Reflow seal. Their duration is proportional to the amount of participants and can vary greatly. These scripts are the most calculation intensive ones and expected to typically run server-side.

\item Scripts executed by each participant, marked with (P), include participant's setup and signing, they're duration is not correlated with the amount of participants. These scripts are expected to typically run in the browser or on mobile devices.

\item Scripts executed by the issuer, marked (I), include issuer's setup and signing, they're duration is not correlated with the amount of participants. These scripts are expected to typically run server-side.
\end{itemize}

Each scripts was executed 50 times, on each platform and each configuration, an the average execution time was extracted.



\subsection*{Findings}

\begin{itemize}
\item The execution time of the scripts in the (A) group, grows linearly with the amount of participants. 

\item On a X86-64 machine, the benchmarks execute on Zenroom CLI have a comparable duration with their counterparts run on WASM. The execution times differ otherwise greatly between Zenroom CLI and Zenroom WASM, on the ARM 32bit based Raspberry Pi 0 and 4 machines. 
While investigating the cause of the differences is beyond the purpose of this paper, we speculate this as signaling different levels of optimization, for the of WASM interpreters built for X86-64 on one hand, and ARM 32bit on the other.  

\item The most numerically outstanding benchmark is the execution time of the issuer's keygen script on Raspberry Pi 0, when compared with the other platform. Once more, investigating the reason for this discrepancy is beyond the scope of this paper: we speculate ECP2 pairing performed in script may justify it.
\end{itemize}


% All results are produced using the free and open source \emph{AGPLv3 license} Zenroom VM long term support release \emph{version 1.2} and its built-in credentials and multidarkroom scenarios using the zencode scripts released in the zencode_multidarkroom distributed examples.

% size progression: 5,10,50,100 participants:
% byte size & 444 & 603 & 624  \\
% byte size & 444 & 1171 & 1192  \\
% byte size & 444 & 4011 & 4032  \\
% byte size & 444 & 7561 & 7582  \\

\onecolumn
\section{Benchmarks}
\label{sec:benchmarks}

Following are the benchmarks of the benchmarks for the (A) group of scripts (whose execution times change based on the amount of participants), running in CLI binaries, grouped by platform.


\subsection*{Zenroom CLI X86-64}


\begin{table}[h!]
  \begin{center}
    \caption{Execution timings on \textbf{CLI X64} in $seconds$ per $participant$}
      \label{tab:table1}
        \begin{tabular} {c|c|c|c|c|c|c}
          \toprule
           \textbf{$_S / _P$} & \textbf{2} & \textbf{10} & \textbf{50} & \textbf{100} & \textbf{1000} & \textbf{5000} \\
          \midrule
          (A) Session start & 0.0188 & 0.0253 & 0.0410 & 0.0623 & 0.1056 & 0.5039 \\
          (A) Collect sign & 0.0729 & 0.0730 & 0.1031 & 0.1373 & 0.7435 & 3.6061 \\
          (A) Verify sign & 0.0405 & 0.0515 & 0.0996 & 0.1619 & 1.3974 & 7.0460 \\
      \bottomrule % end of content
    \end{tabular}
  \end{center}
\end{table}


\begin{figure}[h!]
    \centering
    \includegraphics[width=4in, height=2.6in]{graphs/CLIX64.png}
    \label{fig:galaxy}
\end{figure}




\subsection*{Zenroom CLI Raspberry Pi 4}


\begin{table}[h!]
  \begin{center}
    \caption{Execution times on \textbf{CLI Raspberry 4} in $seconds$ per $participant$}
      \label{tab:table1}
        \begin{tabular} {c|c|c|c|c|c}
          \toprule
           \textbf{$_S / _P$} & \textbf{2} & \textbf{10} & \textbf{50} & \textbf{100} & \textbf{1000} \\
          \midrule
          (A) Session start & 0.0516 & 0.0602 & 0.0674 & 0.0750 & 0.2762 \\
          (A) Collect sign & 0.2087 & 0.2273 & 0.3031 & 0.3942 & 2.1849 \\
          (A) Verify sign & 0.1049 & 0.1393 & 0.2978 & 0.4831 & 4.0688 \\
      \bottomrule % end of content
    \end{tabular}
  \end{center}
\end{table}

\begin{figure}[h!]
    \centering
    \includegraphics[width=4in, height=2.6in]{graphs/CLIRaspi4.png}
    \label{fig:galaxy}
\end{figure}



\pagebreak
\newpage

\subsection*{Zenroom CLI Raspberry Pi 0}

\begin{table}[h!]
  \begin{center}
    \caption{Execution times for\textbf{Zenroom CLI Raspberry Pi 0} in $seconds$ per $participant$}
      \label{tab:table1}
        \begin{tabular} {c|c|c|c|c|c}
          \toprule
           \textbf{$_S / _P$} & \textbf{2} & \textbf{10} & \textbf{50} & \textbf{100} & \textbf{1000} \\
          \midrule
          (A) Session start & 0.2760 & 0.2936 & 0.3413 & 0.3725 & 1.3097 \\
          (A) Collect sign & 1.0439 & 1.1458 & 1.3688 & 1.7669 & 9.6403 \\
          (A) Verify sign & 0.5753 & 0.7199 & 1.3381 & 2.1971 & 17.8956 \\
      \bottomrule % end of content
    \end{tabular}
  \end{center}
\end{table}

\begin{figure}[h!]
    \centering
    \includegraphics[width=4in, height=2.6in]{graphs/CLIRaspi0.png}
    \label{fig:galaxy}
\end{figure}


\subsection*{Zenroom CLI - all platforms}

Following are the benchmarks of the benchmarks for the (P) and the (I) groups of scripts (whose execution times don't change based on the amount of participants), with a comparison of all the platforms, running in CLI binaries.

% OLD TABLE IN ONE PIECE
% \begin{table}[h!]
%  \begin{center}
%    \caption{Execution timings on \textbf{CLI} of scripts in $seconds$ per $platform$}
%      \label{tab:table1}
%        \begin{tabular} {c|c|c|c|c|c|c|c|c}
%          \toprule
% \textbf{$script / arch$} & \textbf{(P) Keygen} & \textbf{(P) Request} & \textbf{(P) Pub-Key} & \textbf{(P) Aggr. Cred.} & \textbf{(P) Sign Session} & \textbf{(I) Keygen}& \textbf{((I) Pub-Key}& \textbf{(I) Sign Req.} \\
%          \midrule
%	X64	&	0.0137	&	0.0391	&	0.0196	&	0.0219	&	0.0521	&	0.0129	&	0.0223	&	0.0524	\\
% Raspberry Pi 4	&	0.0373	&	0.0883	&	0.0475	&	0.0579	&	0.1456	&	0.0404	&	0.0597	&	0.1405	\\
% Raspberry Pi  0	&	0.2492	&	0.5165	&	0.3017	&	0.3469	&	0.6603	&	0.2467	&	0.3766	&	0.7687	\\
%      \bottomrule % end of content
%    \end{tabular}
%  \end{center}
% \end{table}



\begin{table}[h!]
  \begin{center}
    \caption{Execution timings on \textbf{CLI} of scripts in $seconds$ per $platform$}
      \label{tab:table1}
        \begin{tabular} {c|c|c|c|c|c}
          \toprule
\textbf{$script / platf.$} & \textbf{(P) Keygen} & \textbf{(P) Request} & \textbf{(P) Pub-Key} & \textbf{(P) Aggr. Cred.} & \textbf{(P) Sign Session} \\
          \midrule
			X86-X64	&	0.0137	&	0.0391	&	0.0196	&	0.0219	&	0.0521		\\
Raspberry Pi 4	&	0.0373	&	0.0883	&	0.0475	&	0.0579	&	0.1456		\\
Raspberry Pi  0	&	0.2492	&	0.5165	&	0.3017	&	0.3469	&	0.6603		\\
      \bottomrule % end of content
    \end{tabular}
  \end{center}
\end{table}


\begin{table}[h!]
  \begin{center}
    \caption{Execution timings on \textbf{CLI} of scripts in $seconds$ per $platform$}
      \label{tab:table1}
        \begin{tabular} {c|c|c|c}
          \toprule
\textbf{$script / arch$} & \textbf{(I) Keygen} & \textbf{(I) Pub-Key} & \textbf{(I) Sign Req.} \\
          \midrule
			X64	&	0.0129	&	0.0223	&	0.0524	\\
Raspberry Pi 4	&	0.0404	&	0.0597	&	0.1405	\\
Raspberry Pi  0	&	0.2467	&	0.3766	&	0.7687	\\
      \bottomrule % end of content
    \end{tabular}
  \end{center}
\end{table}



\begin{figure}[h!]
    \centering
    \includegraphics[width=6in, height=2.6in]{graphs/CLIfixed.png}
    \label{fig:galaxy}
\end{figure}

\newpage
\pagebreak

Following are the benchmarks of the benchmarks for the (A) group of scripts (whose execution times change based on the amount of participants), running in WASM libraries, grouped by platform.

\subsection*{Zenroom WASM X86-64}

\begin{table}[h!]
  \begin{center}
    \caption{Execution timings on \textbf{WASM X64} in $seconds$ per $participant$}
      \label{tab:table1}
        \begin{tabular} {c|c|c|c|c|c}
          \toprule
           \textbf{$_S / _P$} & \textbf{2} & \textbf{10} & \textbf{50} & \textbf{100} & \textbf{1000} \\
          \midrule
          (A) Session start & 0.0324 & 0.0312 & 0.0373 & 0.0516 & 0.1749 \\
          (A) Collect sign & 0.1180 & 0.1092 & 0.1510 & 0.2467 & 1.1563 \\
          (A) Verify sign & 0.0695 & 0.0688 & 0.1495 & 0.2641 & 2.1554 \\
      \bottomrule % end of content
    \end{tabular}
  \end{center}
\end{table}

\begin{figure}[h!]
    \centering
    \includegraphics[width=4in, height=2.6in]{graphs/WasmX64.png}
    \label{fig:galaxy}
\end{figure}

\newpage

\subsection*{Zenroom WASM Rasperry Pi 4}

\begin{table}[h!]
  \begin{center}
    \caption{Execution timings on \textbf{WASM Raspberry Pi 4} in $seconds$ per $participant$}
      \label{tab:table1}
        \begin{tabular} {c|c|c|c|c|c}
          \toprule
           \textbf{$_S / _P$} & \textbf{2} & \textbf{10} & \textbf{50} & \textbf{100} & \textbf{1000} \\
          \midrule
          (A) Session start & 0.1065 & 0.1092 & 0.1269 & 0.1459 & 0.5432 \\
          (A) Collect sign & 0.3897 & 0.4170 & 0.5741 & 0.7654 & 4.3594 \\
          (A) Verify sign & 0.1880 & 0.2510 & 0.5621 & 0.9494 & 8.1078 \\
      \bottomrule % end of content
    \end{tabular}
  \end{center}
\end{table}

\begin{figure}[h!]
    \centering
    \includegraphics[width=4in, height=2.6in]{graphs/WasmRaspi4.png}
    \label{fig:galaxy}
\end{figure}

\subsection*{Zenroom WASM Rasperry Pi 0}

\begin{table}[h!]
  \begin{center}
    \caption{Execution timings on \textbf{WASM Raspberry Pi 0} in $seconds$ per $participant$}
      \label{tab:table1}
        \begin{tabular} {c|c|c|c|c|c}
          \toprule
           \textbf{$_S / _P$} & \textbf{2} & \textbf{10} & \textbf{50} & \textbf{100} & \textbf{1000} \\
          \midrule
          (A) Session start & 0.8688 & 0.8711 & 1.0392 & 1.2257 & 4.7067 \\
          (A) Collect sign & 2.7272 & 2.8665 & 3.9580 & 5.1851 & 29.0912 \\
          (A) Verify sign & 1.3818 & 1.7820 & 3.8503 & 6.3604 & 53.8938 \\
      \bottomrule % end of content
    \end{tabular}
  \end{center}
\end{table}

\begin{figure}[h!]
    \centering
    \includegraphics[width=4in, height=2.6in]{graphs/WasmRaspi0.png}
    \label{fig:galaxy}
\end{figure}

\newpage


\subsection*{Zenroom WASM - all platforms}

Following are the benchmarks of the benchmarks for the (P) and the (I) groups of scripts (whose executions don't change based on the amount of participants), with a comparison of all the platforms, running in CLI binaries.

% OLD TABLE IN ONE PIECE
% \begin{table}[h!]
%   \begin{center}
%     \caption{Execution timings on \textbf{WASM} of scripts in $seconds$ per $platform$}
%       \label{tab:table1}
%         \begin{tabular} {c|c|c|c|c|c|c|c|c}
%           \toprule
% \textbf{$script / arch$} & \textbf{(P) Keygen} & \textbf{(P) Request} & \textbf{(P) Pub-Key} & \textbf{(P) Aggr. Cred.} & \textbf{(P) Sign Session} & \textbf{(I) Keygen}& \textbf{((I) Pub-Key}& \textbf{(I) Sign Req.} \\
%           \midrule
% X64	&	0.02134	&	0.04906	&	0.02624	&	0.0304	&	0.074510204	&	0.020416667	&	0.03175	&	0.074688889	\\
% Raspberry Pi  4	&	0.169	&	0.3365	&	0.2095	&	0.173	&	0.2705	&	1.01	&	0.276	&	0.6585	\\
% Raspberry Pi  0	&	0.6275	&	1.291	&	0.7185	&	0.811	&	1.9435	&	9.958	&	1.101	&	2.6355	\\
%       \bottomrule % end of content
%     \end{tabular}
%   \end{center}
% \end{table}

\begin{table}[h!]
  \begin{center}
    \caption{Execution times on \textbf{Zenroom WASM} of scripts in $seconds$ per $platform$}
      \label{tab:table1}
        \begin{tabular} {c|c|c|c|c|c}
          \toprule
\textbf{$script / platf.$} & \textbf{(P) Keygen} & \textbf{(P) Request} & \textbf{(P) Pub-Key} & \textbf{(P) Aggr. Cred.} & \textbf{(P) Sign Session} \\
          \midrule
X86-X64			&	0.0213	&	0.0490	&	0.0262	&	0.0304	&	0.0745		\\
Raspberry Pi  4	&	0.169	&	0.3365	&	0.2095	&	0.173	&	0.2705		\\
Raspberry Pi  0	&	0.6275	&	1.291	&	0.7185	&	0.811	&	1.9435		\\
      \bottomrule % end of content
    \end{tabular}
  \end{center}
\end{table}

\begin{table}[h!]
  \begin{center}
    \caption{Execution times on \textbf{Zenroom WASM} of scripts in $seconds$ per $platform$}
      \label{tab:table1}
        \begin{tabular} {c|c|c|c}
          \toprule
\textbf{$script / platf$} &  \textbf{(I) Keygen}& \textbf{(I) Pub-Key}& \textbf{(I) Sign Req.} \\
          \midrule
X86-X64				&		0.0204	&	0.0317	&	0.0746	\\
Raspberry Pi  4	&		1.01	&	0.276	&	0.6585	\\
Raspberry Pi  0	&		9.958	&	1.101	&	2.6355	\\
      \bottomrule % end of content
    \end{tabular}
  \end{center}
\end{table}


\begin{figure}[h!]
    \centering
    \includegraphics[width=6in, height=2.6in]{graphs/WASMfixed.png}
    \label{fig:galaxy}
\end{figure}



\newpage





FINE ANDREA

\newpage





\bibliographystyle{unsrtnat}

\bibliography{references}

\listoffigures

% \subsection{}
% Citations use \verb+natbib+. The documentation may be found at
% \begin{center}
% 	\url{http://mirrors.ctan.org/macros/latex/contrib/natbib/natnotes.pdf}
% \end{center}

% Here is an example usage of the two main commands (\verb+citet+ and \verb+citep+): Some people thought a thing \citep{kour2014real, hadash2018estimate} but other people thought something else \citep{kour2014fast}. Many people have speculated that if we knew exactly why \citet{kour2014fast} thought this\dots

% \subsection{Figures}
% \lipsum[10]
% See Figure \ref{fig:fig1}. Here is how you add footnotes. \footnote{Sample of the first footnote.}
% \lipsum[11]

% \begin{figure}
% 	\centering
% 	\fbox{\rule[-.5cm]{4cm}{4cm} \rule[-.5cm]{4cm}{0cm}}
% 	\caption{Sample figure caption.}
% 	\label{fig:fig1}
% \end{figure}

% \subsection{Tables}
% See awesome Table~\ref{tab:table}.

% The documentation for \verb+booktabs+ (`Publication quality tables in LaTeX') is available from:
% \begin{center}
% 	\url{https://www.ctan.org/pkg/booktabs}
% \end{center}


% \begin{table}
% 	\caption{Sample table title}
% 	\centering
% 	\begin{tabular}{lll}
% 		\toprule
% 		\multicolumn{2}{c}{Part}                   \\
% 		\cmidrule(r){1-2}
% 		Name     & Description     & Size ($\mu$m) \\
% 		\midrule
% 		Dendrite & Input terminal  & $\sim$100     \\
% 		Axon     & Output terminal & $\sim$10      \\
% 		Soma     & Cell body       & up to $10^6$  \\
% 		\bottomrule
% 	\end{tabular}
% 	\label{tab:table}
% \end{table}



\end{document}
